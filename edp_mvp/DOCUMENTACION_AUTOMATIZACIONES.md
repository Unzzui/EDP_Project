# ü§ñ Documentaci√≥n Completa de Automatizaciones Pagora MVP

## üìã √çndice

1. [Resumen Ejecutivo](#resumen-ejecutivo)
2. [Funciones Autom√°ticas](#funciones-autom√°ticas)
3. [Triggers de Base de Datos](#triggers-de-base-de-datos)
4. [Tablas de An√°lisis Autom√°tico](#tablas-de-an√°lisis-autom√°tico)
5. [Campos Calculados Autom√°ticamente](#campos-calculados-autom√°ticamente)
6. [Flujos de Trabajo Automatizados](#flujos-de-trabajo-automatizados)
7. [Ejemplos Pr√°cticos](#ejemplos-pr√°cticos)
8. [Beneficios de la Automatizaci√≥n](#beneficios-de-la-automatizaci√≥n)

---

## üéØ Resumen Ejecutivo

La migraci√≥n de Pagora MVP implementa **automatizaciones cr√≠ticas** que transforman el sistema de un tracker manual a una herramienta de **inteligencia operacional aut√≥noma**.

### **Automatizaciones Implementadas:**

- ‚úÖ **2 Funciones Autom√°ticas** de c√°lculo en tiempo real
- ‚úÖ **2 Triggers de Base de Datos** que se ejecutan autom√°ticamente
- ‚úÖ **3 Tablas de An√°lisis** que se actualizan autom√°ticamente
- ‚úÖ **5 Campos Calculados** sin intervenci√≥n manual
- ‚úÖ **Perfiles de Cliente** que se construyen autom√°ticamente

---

## ü§ñ Funciones Autom√°ticas

### **1. Funci√≥n: `update_dias_en_cliente()`**

#### **¬øQu√© hace?**

Calcula autom√°ticamente el tiempo que un EDP estuvo en manos del cliente para revisi√≥n.

#### **F√≥rmula:**

```sql
dias_en_cliente = fecha_conformidad - fecha_envio_cliente
```

#### **¬øCu√°ndo se ejecuta?**

- **Autom√°ticamente** cada vez que se actualiza cualquier EDP
- **En tiempo real** sin intervenci√≥n manual
- **Solo si** ambas fechas est√°n presentes

#### **C√≥digo de la Funci√≥n:**

```sql
CREATE OR REPLACE FUNCTION update_dias_en_cliente()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.fecha_conformidad IS NOT NULL AND NEW.fecha_envio_cliente IS NOT NULL THEN
        NEW.dias_en_cliente = EXTRACT(DAY FROM NEW.fecha_conformidad - NEW.fecha_envio_cliente);
    END IF;
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

#### **Ejemplo Pr√°ctico:**

```sql
-- Usuario actualiza un EDP
UPDATE edp SET
    fecha_envio_cliente = '2025-01-10',
    fecha_conformidad = '2025-01-25'
WHERE n_edp = 1001;

-- RESULTADO AUTOM√ÅTICO:
-- dias_en_cliente = 15 (calculado autom√°ticamente)
-- updated_at = timestamp actual (actualizado autom√°ticamente)
```

#### **Beneficio:**

- **Mide eficiencia del cliente** autom√°ticamente
- **Identifica patrones de respuesta** sin c√°lculos manuales
- **Alimenta an√°lisis predictivo** de comportamiento de clientes

---

### **2. Funci√≥n: `log_status_change()`**

#### **¬øQu√© hace?**

Registra autom√°ticamente cada cambio de estado de un EDP en una tabla de historial para an√°lisis de cuellos de botella.

#### **¬øCu√°ndo se ejecuta?**

- **Autom√°ticamente** cuando cambia el estado de cualquier EDP
- **Solo si** el estado realmente cambi√≥ (no en actualizaciones sin cambios)
- **En tiempo real** creando registro hist√≥rico

#### **C√≥digo de la Funci√≥n:**

```sql
CREATE OR REPLACE FUNCTION log_status_change()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.estado IS DISTINCT FROM NEW.estado AND NEW.estado IS NOT NULL THEN
        INSERT INTO edp_status_history (edp_id, estado_anterior, estado_nuevo, usuario, trigger_cambio)
        VALUES (NEW.id, COALESCE(OLD.estado, 'SIN_ESTADO'), NEW.estado, COALESCE(NEW.registrado_por, 'SISTEMA'), 'AUTOMATICO');
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

#### **Ejemplo Pr√°ctico:**

```sql
-- Usuario cambia estado de EDP
UPDATE edp SET
    estado = 'APROBADO',
    registrado_por = 'juan.perez'
WHERE n_edp = 1001;

-- RESULTADO AUTOM√ÅTICO en edp_status_history:
-- edp_id: 1001
-- estado_anterior: 'ENVIADO'
-- estado_nuevo: 'APROBADO'
-- usuario: 'juan.perez'
-- trigger_cambio: 'AUTOMATICO'
-- fecha_cambio: timestamp actual
```

#### **Beneficio:**

- **An√°lisis de cuellos de botella** autom√°tico
- **Auditor√≠a completa** de cambios sin esfuerzo manual
- **M√©tricas de eficiencia** por etapa del proceso

---

## ‚ö° Triggers de Base de Datos

### **1. Trigger: `trigger_update_dias_en_cliente`**

#### **Configuraci√≥n:**

```sql
CREATE TRIGGER trigger_update_dias_en_cliente
    BEFORE UPDATE ON edp
    FOR EACH ROW
    EXECUTE FUNCTION update_dias_en_cliente();
```

#### **¬øCu√°ndo se activa?**

- **ANTES** de actualizar cualquier registro en la tabla `edp`
- **Por cada fila** que se actualiza
- **Autom√°ticamente** sin intervenci√≥n

#### **¬øQu√© procesa?**

- Calcula `dias_en_cliente` si las fechas est√°n presentes
- Actualiza `updated_at` con timestamp actual
- Modifica el registro antes de guardarlo

---

### **2. Trigger: `trigger_log_status_change`**

#### **Configuraci√≥n:**

```sql
CREATE TRIGGER trigger_log_status_change
    AFTER UPDATE ON edp
    FOR EACH ROW
    EXECUTE FUNCTION log_status_change();
```

#### **¬øCu√°ndo se activa?**

- **DESPU√âS** de actualizar cualquier registro en la tabla `edp`
- **Por cada fila** que se actualiza
- **Solo si** el estado realmente cambi√≥

#### **¬øQu√© procesa?**

- Compara estado anterior vs nuevo
- Inserta registro en `edp_status_history`
- Captura usuario y timestamp autom√°ticamente

---

## üìä Tablas de An√°lisis Autom√°tico

### **1. Tabla: `edp_status_history`**

#### **Prop√≥sito:**

Registro autom√°tico de **todos los cambios de estado** para an√°lisis de procesos.

#### **Estructura:**

```sql
CREATE TABLE edp_status_history (
    id SERIAL PRIMARY KEY,
    edp_id INTEGER NOT NULL,
    estado_anterior TEXT,
    estado_nuevo TEXT,
    fecha_cambio TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    usuario VARCHAR(100),
    comentario TEXT,
    trigger_cambio VARCHAR(20) DEFAULT 'MANUAL',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### **Se alimenta autom√°ticamente cuando:**

- Cualquier EDP cambia de estado
- Se registra quien hizo el cambio
- Se captura timestamp exacto

#### **An√°lisis que permite:**

```sql
-- Cuellos de botella por estado
SELECT
    estado_anterior,
    estado_nuevo,
    COUNT(*) as numero_transiciones,
    AVG(EXTRACT(DAY FROM LAG(fecha_cambio) OVER (ORDER BY fecha_cambio))) as dias_promedio
FROM edp_status_history
GROUP BY estado_anterior, estado_nuevo
ORDER BY numero_transiciones DESC;
```

---

### **2. Tabla: `client_profiles`**

#### **Prop√≥sito:**

Perfiles autom√°ticos de **comportamiento de clientes** para an√°lisis predictivo.

#### **Estructura:**

```sql
CREATE TABLE client_profiles (
    id SERIAL PRIMARY KEY,
    cliente VARCHAR(255) UNIQUE NOT NULL,
    promedio_dias_conformidad DECIMAL(5,2),
    tasa_aprobacion_porcentaje DECIMAL(5,2),
    numero_total_edps INTEGER DEFAULT 0,
    monto_total_aprobado DECIMAL(15,2) DEFAULT 0,
    ultimo_edp_fecha TIMESTAMP,
    patron_pago VARCHAR(20), -- RAPIDO, NORMAL, LENTO
    requiere_seguimiento_especial BOOLEAN DEFAULT FALSE,
    notas_comportamiento TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### **Se actualiza autom√°ticamente con:**

- Datos agregados de todos los EDPs por cliente
- C√°lculo autom√°tico de patrones de pago
- Clasificaci√≥n autom√°tica por velocidad de respuesta

#### **Inicializaci√≥n autom√°tica:**

```sql
-- Se ejecut√≥ autom√°ticamente en la migraci√≥n
INSERT INTO client_profiles (
    cliente,
    numero_total_edps,
    monto_total_aprobado,
    ultimo_edp_fecha,
    promedio_dias_conformidad
)
SELECT
    cliente,
    COUNT(*) as numero_total_edps,
    SUM(COALESCE(monto_aprobado, 0)) as monto_total_aprobado,
    MAX(fecha_conformidad) as ultimo_edp_fecha,
    AVG(dias_en_cliente) as promedio_dias_conformidad
FROM edp
WHERE cliente IS NOT NULL
GROUP BY cliente;
```

---

### **3. Tabla: `kpi_snapshots`**

#### **Prop√≥sito:**

Instant√°neas autom√°ticas de **KPIs cr√≠ticos** para an√°lisis de tendencias temporales.

#### **Estructura:**

```sql
CREATE TABLE kpi_snapshots (
    id SERIAL PRIMARY KEY,
    fecha_snapshot DATE NOT NULL,
    total_pendiente DECIMAL(15,2),
    total_aprobado_mes DECIMAL(15,2),
    numero_edps_activos INTEGER,
    tasa_aprobacion_porcentaje DECIMAL(5,2),
    tiempo_promedio_conformidad DECIMAL(5,2),
    clientes_activos INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(fecha_snapshot)
);
```

#### **Se puede automatizar con:**

```sql
-- Script para ejecutar diariamente (ej: cron job)
INSERT INTO kpi_snapshots (
    fecha_snapshot,
    total_pendiente,
    total_aprobado_mes,
    numero_edps_activos,
    tasa_aprobacion_porcentaje,
    tiempo_promedio_conformidad,
    clientes_activos
)
SELECT
    CURRENT_DATE,
    SUM(CASE WHEN estado != 'PAGADO' THEN monto_aprobado ELSE 0 END),
    SUM(CASE WHEN estado = 'APROBADO' AND DATE_TRUNC('month', fecha_conformidad) = DATE_TRUNC('month', CURRENT_DATE) THEN monto_aprobado ELSE 0 END),
    COUNT(CASE WHEN estado NOT IN ('PAGADO', 'CANCELADO') THEN 1 END),
    AVG(CASE WHEN estado = 'APROBADO' THEN 100 ELSE 0 END),
    AVG(dias_en_cliente),
    COUNT(DISTINCT cliente)
FROM edp
ON CONFLICT (fecha_snapshot) DO UPDATE SET
    total_pendiente = EXCLUDED.total_pendiente,
    total_aprobado_mes = EXCLUDED.total_aprobado_mes;
```

---

## üßÆ Campos Calculados Autom√°ticamente

### **1. Campo: `dias_en_cliente`**

- **Tabla:** `edp`
- **C√°lculo:** `fecha_conformidad - fecha_envio_cliente`
- **Cu√°ndo:** En cada UPDATE de EDP
- **Uso:** Medir eficiencia de respuesta del cliente

### **2. Campo: `prioridad`**

- **Tabla:** `edp`
- **C√°lculo:** Basado en `monto_aprobado`
  - > 10M = 'ALTA'
  - > 5M = 'MEDIA'
  - Resto = 'BAJA'
- **Cu√°ndo:** Se calcul√≥ en migraci√≥n, se puede recalcular autom√°ticamente

### **3. Campo: `updated_at`**

- **Tabla:** `edp`, `client_profiles`, `kpi_snapshots`
- **C√°lculo:** `CURRENT_TIMESTAMP`
- **Cu√°ndo:** En cada UPDATE autom√°ticamente

### **4. Campo: `patron_pago`**

- **Tabla:** `client_profiles`
- **C√°lculo:** Basado en `promedio_dias_conformidad`
  - ‚â§ 15 d√≠as = 'RAPIDO'
  - ‚â§ 30 d√≠as = 'NORMAL'
  - > 30 d√≠as = 'LENTO'
- **Cu√°ndo:** Se actualiz√≥ en migraci√≥n

### **5. Campo: `numero_total_edps`**

- **Tabla:** `client_profiles`
- **C√°lculo:** `COUNT(*)` de EDPs por cliente
- **Cu√°ndo:** Se calcul√≥ en migraci√≥n inicial

---

## üîÑ Flujos de Trabajo Automatizados

### **Flujo 1: Actualizaci√≥n de EDP**

```mermaid
graph TD
    A[Usuario actualiza EDP] --> B[Trigger BEFORE UPDATE]
    B --> C[Funci√≥n update_dias_en_cliente]
    C --> D[Calcula dias_en_cliente]
    D --> E[Actualiza updated_at]
    E --> F[Guarda cambios en BD]
    F --> G[Trigger AFTER UPDATE]
    G --> H[Funci√≥n log_status_change]
    H --> I{¬øCambi√≥ estado?}
    I -->|S√≠| J[Inserta en edp_status_history]
    I -->|No| K[No hace nada]
    J --> L[Proceso completo]
    K --> L
```

### **Flujo 2: An√°lisis de Cliente**

```mermaid
graph TD
    A[M√∫ltiples EDPs del cliente] --> B[client_profiles se calcula]
    B --> C[promedio_dias_conformidad]
    C --> D[patron_pago autom√°tico]
    D --> E[RAPIDO/NORMAL/LENTO]
    E --> F[An√°lisis predictivo habilitado]
```

### **Flujo 3: An√°lisis de Tendencias**

```mermaid
graph TD
    A[Snapshot diario KPIs] --> B[kpi_snapshots]
    B --> C[An√°lisis temporal]
    C --> D[Tendencias autom√°ticas]
    D --> E[Alertas predictivas]
```

---

## üí° Ejemplos Pr√°cticos Detallados

### **Ejemplo 1: Ciclo Completo de EDP**

```sql
-- 1. Crear nuevo EDP
INSERT INTO edp (n_edp, proyecto, cliente, monto_propuesto, estado, registrado_por)
VALUES (2001, 'Proyecto Alpha', 'Cliente XYZ', 8500000, 'REVISION', 'maria.gonzalez');

-- 2. Enviar al cliente
UPDATE edp SET
    estado = 'ENVIADO',
    fecha_envio_cliente = '2025-01-15',
    registrado_por = 'maria.gonzalez'
WHERE n_edp = 2001;

-- AUTOM√ÅTICO: Se registra en edp_status_history:
-- estado_anterior: 'REVISION' ‚Üí estado_nuevo: 'ENVIADO'

-- 3. Cliente da conformidad
UPDATE edp SET
    estado = 'APROBADO',
    fecha_conformidad = '2025-01-22',
    monto_aprobado = 8500000,
    registrado_por = 'maria.gonzalez'
WHERE n_edp = 2001;

-- AUTOM√ÅTICO:
-- 1. dias_en_cliente = 7 (calculado autom√°ticamente)
-- 2. prioridad = 'BAJA' (por monto < 10M)
-- 3. Se registra cambio ENVIADO ‚Üí APROBADO en historial

-- 4. Verificar automatizaciones
SELECT
    n_edp,
    dias_en_cliente,  -- 7 (autom√°tico)
    prioridad,        -- 'BAJA' (autom√°tico)
    updated_at        -- timestamp actual (autom√°tico)
FROM edp WHERE n_edp = 2001;

-- Ver historial autom√°tico
SELECT * FROM edp_status_history
WHERE edp_id = (SELECT id FROM edp WHERE n_edp = 2001)
ORDER BY fecha_cambio;
```

### **Ejemplo 2: An√°lisis Autom√°tico de Cliente**

```sql
-- Despu√©s de varios EDPs, el perfil se construye autom√°ticamente
SELECT
    cliente,
    numero_total_edps,
    promedio_dias_conformidad,
    patron_pago,  -- Calculado autom√°ticamente
    monto_total_aprobado
FROM client_profiles
WHERE cliente = 'Cliente XYZ';

-- Resultado ejemplo:
-- cliente: 'Cliente XYZ'
-- numero_total_edps: 12
-- promedio_dias_conformidad: 8.5
-- patron_pago: 'RAPIDO' (porque < 15 d√≠as)
-- monto_total_aprobado: 45,300,000
```

### **Ejemplo 3: An√°lisis de Cuellos de Botella**

```sql
-- Analizar autom√°ticamente d√≥nde se atascan los EDPs
SELECT
    estado_anterior,
    estado_nuevo,
    COUNT(*) as numero_transiciones,
    AVG(EXTRACT(EPOCH FROM (fecha_cambio - LAG(fecha_cambio) OVER (PARTITION BY edp_id ORDER BY fecha_cambio)))/86400) as dias_promedio_en_estado
FROM edp_status_history
WHERE fecha_cambio > CURRENT_DATE - INTERVAL '90 days'
GROUP BY estado_anterior, estado_nuevo
HAVING COUNT(*) > 5
ORDER BY dias_promedio_en_estado DESC;

-- Identifica autom√°ticamente:
-- ¬øD√≥nde se demoran m√°s los EDPs?
-- ¬øQu√© transiciones son m√°s lentas?
-- ¬øQu√© cuellos de botella existen?
```

---

## üéØ Beneficios de la Automatizaci√≥n

### **üîÑ Operacionales**

- **Cero esfuerzo manual** para c√°lculos cr√≠ticos
- **Datos siempre actualizados** en tiempo real
- **Eliminaci√≥n de errores** de c√°lculo manual
- **Consistencia total** en m√©tricas

### **üìä Anal√≠ticos**

- **An√°lisis predictivo** autom√°tico de clientes
- **Identificaci√≥n autom√°tica** de cuellos de botella
- **Tendencias temporales** sin trabajo manual
- **KPIs en tiempo real** siempre disponibles

### **üéØ Estrat√©gicos**

- **Decisiones basadas en datos** autom√°ticos
- **Alertas predictivas** de problemas potenciales
- **Optimizaci√≥n continua** del proceso
- **Inteligencia operacional** sin esfuerzo adicional

### **üí∞ Financieros**

- **ROI inmediato** por automatizaci√≥n
- **Reducci√≥n de tiempo** en tareas administrativas
- **Mejora en cash flow** por mejor seguimiento
- **Identificaci√≥n autom√°tica** de clientes problem√°ticos

---

## üöÄ Implementaci√≥n Actual

### **‚úÖ Estado Actual (Post-Migraci√≥n):**

- ‚úÖ Todas las funciones autom√°ticas activas
- ‚úÖ Triggers funcionando en tiempo real
- ‚úÖ Tablas de an√°lisis pobladas
- ‚úÖ Campos calculados inicializados
- ‚úÖ Datos hist√≥ricos migrados

### **üîÆ Pr√≥ximos Pasos Recomendados:**

1. **Script diario** para actualizar `kpi_snapshots`
2. **Dashboard** que consuma datos autom√°ticos
3. **Alertas** basadas en umbrales autom√°ticos
4. **Reportes** que se generen autom√°ticamente

---

## üìù Mantenimiento

### **üîß Las automatizaciones son:**

- **Auto-mantenidas** - No requieren intervenci√≥n
- **Eficientes** - Solo procesan cuando es necesario
- **Robustas** - Manejan casos edge autom√°ticamente
- **Escalables** - Funcionan con cualquier volumen de datos

### **‚ö†Ô∏è Monitoreo recomendado:**

```sql
-- Verificar que triggers est√°n activos
SELECT * FROM information_schema.triggers
WHERE trigger_schema = 'public'
AND event_object_table = 'edp';

-- Verificar crecimiento de tablas de an√°lisis
SELECT
    schemaname,
    tablename,
    n_tup_ins as inserts,
    n_tup_upd as updates
FROM pg_stat_user_tables
WHERE tablename IN ('edp_status_history', 'client_profiles', 'kpi_snapshots');
```

---

**üìß Documentaci√≥n creada por:** Pagora MVP Enhancement Team  
**üìÖ Fecha:** 2025-01-28  
**üîÑ Versi√≥n:** 1.0  
**üéØ Estado:** Implementado y Activo
